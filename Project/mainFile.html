<!DOCTYPE html>
<html>
<body>
  <script type="text/javascript">
    class vec { //Setting up vec class to store vectors in future
      constructor(x,y){
        this.x = x;
        this.y = y;
      }
      add(vec2){ //setting up basic vector operations
        this.x += vec2.x;
        this.y += vec2.y;
      }
      add1(vec2){
        var vec3 = new vec(this.x + vec2.x, this.y + vec2.x);
        return vec3
      }
      sub(vec2){
        this.x -= vec2.x;
        this.y -= vec2.y;
      }
      sub1(vec2){
        var vec3 = new vec(this.x - vec2.x, this.y - vec2.y);
        return vec3
      }
      mult(scalar){
        this.x *= scalar;
        this.y *= scalar;
      }
      mult1(scalar){
        var vec3 = new vec(this.x * scalar, this.y * scalar);
        return vec3
      }
      divi(scalar){
        this.x /= scalar;
        this.y /= scalar;
      }
      divi1(scalar){
        var vec3 = new vec(this.x * scalar, this.y * scalar);
        return vec3
      }

      dotproduct(vec2){
        return this.x*vec2.x + this.y*vec2.y;
      }
    }
    class ob { //Setting up basic object class which other rigid bodies will extend from
      constructor(position, speed, acceleration, mass, restitution){
        this.position = position; //stored as vector
        this.speed = speed; //stored as vector
        this.acceleration = acceleration; //stored as vector
        this.mass = mass; //stored as scalar
        this.restitution = restitution; //bouncyness factor
      }
      addDispByFrame(){ //Will be called every cycle to change displacement based on speed
        this.speed.divi(60);
        this.position.add(this.speed);//speed stored in m/s so divided by 60 for 60fps
        this.speed.mult(60);//set back to original value
      }
      addSpeedByFrame(){
        this.acceleration.divi(60);
        this.speed.add(this.acceleration);//acceleration stored in m/s so divided by 60 for 60fps
        this.acceleration.mult(60);//set back to original value
      }
    }

    class circle extends ob{ //circle is a subclass of ob
      constructor(position, speed, acceleration, mass,restitution,radius){
        super(position, speed, acceleration, mass, restitution);
        this.radius = radius
      }
    }

    class AABB extends ob{ //AABB is a subclass of ob
      constructor(position, speed, acceleration, mass, restitution, min, max){
        super(position, speed, acceleration, mass, restitution);
        this.min = min; //Stored as vector, represents top left of AABB
        this.max = max; //Stored as vector, represents bottom right of ABB
      }
    }

    class poly extends ob{
      constructor(position, speed, acceleration, mass, restitution, points){
        super(position, speed, acceleration, mass, restitution);
        this.points = points;
        this.radius = 0;
        var disp = 0;
        for (var i = 0; i < points.length; i++){
          disp = ((position.x - points[i].x)**2 +(position.y - points[i].y**2))**0.5;
          this.radius += disp;
        }
        this.radius /= points.length;
      }
      addDispByFrame(){ //Will be called every cycle to change displacement based on speed
        this.speed.divi(60);
        this.position.add(this.speed);//speed stored in m/s so divided by 60 for 60fps
        for (var i = 0; i < this.points.length; i++){
          this.points[i].x += this.speed.x;
          this.points[i].y += this.speed.y;
        }
        this.speed.mult(60);
      }
    }

    function polygonCollision(ob1, ob2){
      //code copied AND adapted from https://stackoverflow.com/questions/10962379/how-to-check-intersection-between-2-rotated-rectangles [accessed 21/08/2019] starts here
      var a = ob1.points;
      var b = ob2.points;
      var polygons = [a,b];
      var minA, maxA, projected, i, i1, j, minB, maxB;
      var minIntersection = Infinity;
      var intersectionNormal = undefined;
      for (i = 0; i < polygons.length; i++) {

          // for each polygon, look at each edge of the polygon, and determine if it separates
          // the two shapes
          var polygon = polygons[i];
          for (i1 = 0; i1 < polygon.length; i1++) {

              // grab 2 vertices to create an edge
              var i2 = (i1 + 1) % polygon.length;
              var p1 = polygon[i1];
              var p2 = polygon[i2];

              // find the normalised line perpendicular to this edge
              len1 = p2.y - p1.y
              len2 = p1.x - p2.x
              sumsquare = len1**2 + len2**2 //doing this according to advice from http://www.dyn4j.org/2010/01/sat/
              sqroot = sumsquare**0.5
              var normal = { x: len1/sqroot, y: len2/sqroot };

              minA = maxA = undefined;
              // for each vertex in the first shape, project it onto the line perpendicular to the edge
              // and keep track of the min and max of these values
              for (j = 0; j < a.length; j++) {
                  projected = normal.x * a[j].x + normal.y * a[j].y;
                  if (minA === undefined || projected < minA) {
                      minA = projected;
                  }
                  if (maxA === undefined || projected > maxA) {
                      maxA = projected;
                  }
              }

              // for each vertex in the second shape, project it onto the line perpendicular to the edge
              // and keep track of the min and max of these values
              minB = maxB = undefined;
              for (j = 0; j < b.length; j++) {
                  projected = normal.x * b[j].x + normal.y * b[j].y;
                  if (minB === undefined || projected < minB) {
                      minB = projected;
                  }
                  if (maxB === undefined || projected > maxB) {
                      maxB = projected;
                  }
              }

              // if there is no overlap between the projects, the edge we are looking at separates the two
              // polygons, and we know there is no overlap
              if (maxA < minB || maxB < minA) {
                  console.log("polygons don't intersect!");
                  return [false];
              }
              else{
                //console.log("yeet")
                if ((maxA - minB) < minIntersection){
                  minIntersection = maxA - minB;
                  intersectionNormal = normal;
                }
                if ((maxB - minA) < minIntersection){
                  minIntersection = maxB - minA;
                  normal.x = -normal.x;
                  normal.y = -normal.y;
                  intersectionNormal = normal
                }

              }
              }
          }
      console.log("polygons intersect!");
      var returnlist = [true, minIntersection, intersectionNormal];
      return returnlist;
      //code copied and adapted from https://stackoverflow.com/questions/10962379/how-to-check-intersection-between-2-rotated-rectangles [accessed 21/08/2019] ends here

    }

    function resolvePolygon(ob1, ob2, returnlist){
      //console.log(ob1.speed)
      //console.log(ob2.speed)
      minIntersection = returnlist[1];
      intersectionNormal = returnlist[2];
      //console.log(intersectionNormal)
      var normal = new vec(intersectionNormal.x, intersectionNormal.y);

      normal.mult(minIntersection)
      obj = undefined;
      if (ob1.restitution < ob2.restitution){
        obj = ob1;
        normal.mult(-1)
      }
      else{
        obj = ob2;
      }
      obj.position.x += normal.x;
      obj.position.y += normal.y;
      for (var i = 0; i < obj.points.length; i++){
        obj.points[i].x += normal.x;
        obj.points[i].y += normal.y;
      }

      oldvelx1 = ob1.speed.x; //preventing passing by reference annoyance
      oldvely1 = ob1.speed.y;
      oldvelx2 = ob2.speed.x;
      oldvely2 = ob2.speed.y;



//console.log(oldvelx2, oldvely2);
      //method taken from https://gamedev.stackexchange.com/questions/48587/resolving-a-collision-with-forces
      var frictionFactor = 0.4;

      ob1.speed.x = frictionFactor*((oldvelx1 * (ob1.mass - ob2.mass)) + (oldvelx2 * 2 * ob2.mass))/(ob1.mass + ob2.mass)//**0.5
      ob1.speed.y = frictionFactor*((oldvely1 * (ob1.mass - ob2.mass)) + (oldvely2 * 2 * ob2.mass))/(ob1.mass + ob2.mass)//**0.5
      ob2.speed.x = frictionFactor*((oldvelx2 * (ob2.mass - ob1.mass)) + (oldvelx1 * 2 * ob1.mass))/(ob1.mass + ob2.mass)//**0.5)
      ob2.speed.y = frictionFactor*((oldvely2 * (ob2.mass - ob1.mass)) + (oldvely1 * 2 * ob1.mass))/(ob1.mass + ob2.mass)//**0.5
      // ob1.speed.x = ((oldvelx1 * (ob1.mass - ob2.mass)) + (oldvelx2 * 2 * ob2.mass))/(ob1.mass + ob2.mass)//**0.5
      // ob1.speed.y = ((oldvely1 * (ob1.mass - ob2.mass)) + (oldvely2 * 2 * ob2.mass))/(ob1.mass + ob2.mass)//**0.5
      // ob2.speed.x = ((oldvelx2 * (ob2.mass - ob1.mass)) + (oldvelx1 * 2 * ob1.mass))/(ob1.mass + ob2.mass)//**0.5)
      // ob2.speed.y = ((oldvely2 * (ob2.mass - ob1.mass)) + (oldvely1 * 2 * ob1.mass))/(ob1.mass + ob2.mass)//**0.5
      //console.log(oldvelx1, oldvely1);

    }

    function normalGravity(objectList){
      for (var i = 0; i < objectList.length; i++){
        objectList[i].acceleration.y = 9.8;
      }
      return objectList
    }

    function alternativeGravity(objectList){
      var x = 1;


      var g = (0.000000000066726)
      for (var i = 0; i < objectList.length; i++){
        for (var j = x; j < objectList.length; j++){
          if (i != j){
        ob1 = objectList[i];
        ob2 = objectList[j];
        var direction = ob2.position.sub1(ob1.position);
        // console.log(ob2.position);
        // console.log(ob1.position)
        // console.log(direction);
        //return;
        //var direction = new vec(ob2.position.x - ob1.position.x,ob2.position.y - ob1.position.y);
        console.log(direction);
        var absol = (direction.x**2 + direction.y**2)**0.5;
        direction.divi(absol);
        var a = 1;
        var b = 1;
        var c = 1;
        var d = 1;
        if ((ob1.position.x <= ob2.position.x) && (ob1.position.y <= ob2.position.y)){
          console.log("1")
          a = -1;
          b = -1;
          c = 1;
          d = 1;
        }
        else if ((ob1.position.x >= ob2.position.x) && (ob1.position.y >= ob2.position.y)){
          console.log("2")
        a = 1;
        b = 1;
        c = -1;
        d = -1;
        }
        else if ((ob1.position.x >= ob2.position.x) && (ob1.position.y <= ob2.position.y)){
          console.log("3")
        c  = -1;
        d = -1;
      }
        else if ((ob1.position.x <= ob2.position.x) && (ob1.position.y >= ob2.position.y)){
          console.log("4")
      a = -1;
      b = -1;
      }
        var direction1 = new vec(direction.x,direction.y);
        var direction2 = new vec(-direction.x,-direction.y);
        console.log(absol)
        // var direction1 = new vec(a*direction.x,c*direction.y);
        // var direction2 = new vec(b*direction.x,d*direction.y);
        var accel1 = direction1.mult1(g*((ob2.mass)/(absol**2)));
        //console.log(g*((ob2.mass*ob1.mass)/(absol**2)));
        var accel2 = direction2.mult1(g*((ob1.mass)/(absol**2)));
        ob1.acceleration.add(accel1);
        ob2.acceleration.add(accel2);
      }

        //console.log(ob1.acceleration);
        //console.log(ob2.acceleration);


        }
      x++;
      }
      return objectList;
    }

    function startloop(canvas, ctx, objectList){
      var intervalID = setInterval( function() {loop(canvas, ctx, objectList, intervalID);}, 1000/60);
    }

    function loop(canvas, ctx, objectList, intervalID){
      //console.log(objectList);
      ctx.clearRect(0,0,canvas.width, canvas.height);
      //ctx.fillStyle = "#FFFFFF";
      //ctx.fillRect(0,0, canvas.width, canvas.height);
      for (var i = 0; i <objectList.length; i++){
        objectList[i].acceleration.mult(0);
        //console.log(objectList[i].acceleration);
      }
      var x = 1;
      for (var i = 0; i < objectList.length; i++){
        for (var j = x; j < objectList.length; j++){
          ob1 = objectList[i];
          ob2 = objectList[j];
          collided = polygonCollision(ob1, ob2);
          //console.log(collided);
          if (collided[0] === true){
            resolvePolygon(ob1, ob2, collided);
          }
        }
        x++;
      }
      objectList = alternativeGravity(objectList);
      //console.log(objectList[0].acceleration)
      for (var i = 0; i <objectList.length; i++){
        objectList[i].addSpeedByFrame();
        objectList[i].addDispByFrame();
        console.log(objectList[i].position);
         //console.log(objectList[i].speed);
        // console.log(objectList[i].acceleration);
      }



      var scale = 1;
      ctx.beginPath();
      for (var i = 0; i < objectList.length; i++){
        ctx.moveTo(objectList[i].points[0].x/scale,objectList[i].points[0].y/scale);
        for (var j = 1; j < objectList[i].points.length + 1; j++){
          ctx.lineTo(objectList[i].points[j % objectList[i].points.length].x/scale,objectList[i].points[j % objectList[i].points.length].y/scale);
        }
        ctx.stroke();

      }
      //ctx.clearRect(0,0,canvas.width, canvas.height);

    }

    function createVector(x, y){
      var newVec = new vec(x, y);
      return newVec
    }

    function createPoly(positionx, positiony, speedx, speedy, accelerationx, accelerationy, mass, restitution, shape, size){
      var position = createVector(positionx, positiony);
      var speed = createVector(speedx, speedy);
      var acceleration = createVector(accelerationx, accelerationy)
      var points = []
      if (shape === "triangle"){
        points = [{x:-0.57735026919,y:0.5},{x:0.57735026919,y:0.5},{x:0,y:-0.5}]
      }
      if (shape === "square"){
        points = [{x:0.5,y:0.5},{x:0.5,y:-0.5},{x:-0.5,y:-0.5},{x:-0.5,y:0.5},]
      }
      if (shape === "pentagon"){
        points = [{x:-0.29389262614,y:0.5},{x:0.29389262614,y:0.5},{x:0.475528258141,y:0.059016994374},{x:0,y:-0.5},{x:-0.475528258141,y:0.059016994374}]
      }
      if (shape === "hexagon"){
        points = [{x:-0.288675134595,y:0.5},{x:0.288675134595,y:0.5},{x:0.57735026919,y:0},{x:0.288675134595,y:-0.5},{x:-0.288675134595,y:-0.5},{x:-0.57735026919,y:0}]
      }


      for (var i = 0; i < points.length; i++){
        points[i].x += positionx;
        points[i].y += positiony;
        points[i].x *= size;
        points[i].y *= size;
      }

      var pol = new poly(position, speed, acceleration, mass, restitution, points);
      return pol;

    }

    var canvas = document.createElement("Canvas")
    canvas.width = 500;
    canvas.height = 500;
    canvas.style = "border:1px solid #000000";
    canvas.style = "position: absolute; top: 0px; left: 0px; right: 0px; bottom: 0px; margin: auto; border:2px solid black";
    var ctx = canvas.getContext("2d");
    document.body.appendChild(canvas);

    //used for testing v

    //var position1 = new vec(15600000,400000000);
    //var position = new vec(400000000,400000000);

    var position = new vec(250,6371000);
    //var position1 = new vec(0, 6378100)//8000000
    //var position1 = new vec(22500,25500)
    var position1 = new vec(285,5)
    //var position1 = new vec(225,285)
    //var position2 = new vec(285, 225)
    //var position1 = new vec(285,225)
    var speed = new vec(0, 0);
    var speed1 = new vec(0, 0);
    var speed2 = new vec(0,0)
    //console.log(speed1.x, speed1.y)
    var acceleration = new vec(0,0);
    var acceleration1 = new vec(0,0);
    var acceleration2 = new vec(0,0);
    var mass = 10;
    //var points = [{x:25000,y:25000},{x:25000,y:26000},{x:26000,y:26000},{x:26000,y:25000}];
    //var points = [{x:0,y:50000},{x:0,y:30000},{x:50000,y:30000},{x:50000,y:50000}];
    //var points = [{x:392000000,y:392000000},{x:408000000,y:392000000},{x:408000000,y:408000000},{x:392000000,y:408000000}];
    var points = [{x:0,y:500},{x:0,y:300},{x:500,y:300},{x:500,y:500}];

    //var points1 = [{x:7600000,y:392000000},{x:23600000,y:392000000},{x:23600000,y:408000000},{x:7600000,y:408000000}];
    var points1 = [{x:280,y:0},{x:280,y:10},{x:290,y:10},{x:290,y:0}];
    //var points2 = [{x:220,y:280},{x:220,y:290},{x:230,y:290},{x:230,y:280}];
    //var points3 = [{x:280,y:220},{x:280,y:230},{x:290,y:230},{x:290,y:220}];


    //var poly1 = new poly(position, speed, acceleration, 5972000000000000000000000, 7, points)
    var poly1 = new poly(position, speed, acceleration, 5972000000000000000000000, 7, points)
    var poly2 = new poly(position1, speed1, acceleration1, 80, 6, points1)

    //var poly1 = new poly(position, speed, acceleration,60000000000000, 7,points1)
    //var poly2 = new poly(position1, speed1, acceleration1, 73470000000000000000000, 6, points1)
  //  var poly2 = new poly(position1, speed1, acceleration1, 60000000000000, 6, points2)
    //var poly3 = new poly(position2, speed2, acceleration2, 60000000000000, 6, points3)

    //console.log(polygonCollision(poly1, poly2));
    var poly3 = createPoly(2,2,0,0,0,0,50,4,"hexagon",20)
    var oblist = [poly1, poly2,poly3];
    startloop(canvas, ctx, oblist);
    //polygonCollision(poly1, poly2);
    //alternativeGravity([poly1, poly2])
    // console.log(poly1.position);
    // console.log(poly1.speed);
    // console.log(poly1.acceleration);


    //resolvePolygon(poly1, poly2, polygonCollision(poly1, poly2));
    //console.log(poly1.points);
    //console.log(poly2.points);


  </script>
</body>
</html>
